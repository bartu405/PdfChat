# PDF Chat API with Gemini Integration

## Project Overview
This project provides an API that allows users to upload PDF documents and interact with their content using natural language queries. The API extracts text from the uploaded PDFs and leverages the Google Gemini API (LLM) to generate responses to user queries based on the content of the PDFs.

### Key Features:
- **Upload PDF Documents:** Users can upload PDF files to the API.
- **Text Extraction:** The API extracts and cleans text from the PDFs.
- **Chat with PDFs:** Users can send queries related to the PDF content.
- **LLM Integration:** Uses Google Gemini API to generate responses to user queries.
- **Error Handling and Logging:** Comprehensive error handling and logging for debugging and monitoring.
- **Caching for Frequently Asked Queries:** The API caches responses to frequently asked questions, reducing response times for repeated queries.

## Setup Instructions

### Prerequisites
- **Python:** Version 3.7 or higher
- **Virtual Environment Tool:** venv or conda
- **Git:** For cloning the repository

### Environment Configuration

1. **Clone the Repository**
   ```bash
   git clone <repository_url>
   cd <repository_directory>
   ```
   Replace `<repository_url>` with the URL of your repository and `<repository_directory>` with the directory name.

2. **Create and Activate a Virtual Environment**
   Using venv:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. **Install Dependencies**
   ```bash
   pip install -r requirements.txt
   ```

4. **Environment Variables**
   Create a `.env` file in the root directory to store environment variables.
   ```bash
   touch .env
   ```
   Add the following content to the `.env` file:
   ```dotenv
   GEMINI_API_KEY=your_gemini_api_key_here
   ```
   Replace `your_gemini_api_key_here` with your actual Google Gemini API key.  
   Note: Do not commit the `.env` file to version control.

5. **Load Environment Variables in the Code**
   Ensure the following lines are present in your `main.py` or configuration file to load the environment variables:
   ```python
   from dotenv import load_dotenv
   load_dotenv()
   ```

6. **Configure the Gemini API**
   In your `main.py`, configure the Gemini API:
   ```python
   import google.generativeai as genai
   import os

   genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
   ```

7. **Run the Application**
   Start the FastAPI application using Uvicorn:
   ```bash
   uvicorn main:app --reload
   ```
   The API will be available at `http://127.0.0.1:8000`.

## API Endpoints

1. **Upload PDF**
   - **Endpoint**
     ```bash
     POST /v1/pdf
     ```
   - **Description**
     Uploads a PDF file to the server, extracts its text, and stores it for future queries.

   - **Request**
     - **Headers:** `Content-Type: multipart/form-data`
     - **Body:** The PDF file to upload.

     Example using curl:
     ```bash
     curl -X POST "http://127.0.0.1:8000/v1/pdf" \
       -F "file=@/path/to/your/pdf/file.pdf"
     ```

   - **Response**
     - **Status Code:** `200 OK`
     - **Body:**
       ```json
       {
         "pdf_id": "unique_identifier_for_uploaded_pdf"
       }
       ```

   - **Error Responses**
     - `400 Bad Request:` If the file is not a PDF.
       ```json
       {
         "detail": "Invalid file type. Only PDFs are allowed."
       }
       ```
     - `500 Internal Server Error:` If an error occurs during PDF processing.
       ```json
       {
         "detail": "Error processing PDF: <error_message>"
       }
       ```

2. **Chat with PDF**
   - **Endpoint**
     ```bash
     POST /v1/chat/{pdf_id}
     ```
   - **Description**
     Sends a query to the server related to the content of the PDF identified by `pdf_id`.

   - **Request**
     - **Headers:** `Content-Type: application/json`
     - **Path Parameter:**
       - `pdf_id:` The unique identifier of the uploaded PDF.
     - **Body:**
       ```json
       {
         "query": "Your question about the PDF content."
       }
       ```

     Example using curl:
     ```bash
     curl -X POST "http://127.0.0.1:8000/v1/chat/{pdf_id}" \
       -H "Content-Type: application/json" \
       -d '{"query": "What is the main topic of this document?"}'
     ```

   - **Response**
     - **Status Code:** `200 OK`
     - **Body:**
       ```json
       {
         "response": "The answer generated by the Gemini API."
       }
       ```

   - **Error Responses**
     - `400 Bad Request:` If the query is empty.
       ```json
       {
         "detail": "Query cannot be empty"
       }
       ```
     - `404 Not Found:` If the `pdf_id` does not exist.
       ```json
       {
         "detail": "PDF not found."
       }
       ```
     - `500 Internal Server Error:` If an error occurs during response generation.
       ```json
       {
         "detail": "Error generating response: <error_message>"
       }
       ```

## Caching Mechanism for Frequently Asked Queries

To improve response times for frequently asked questions (FAQs), the API implements an in-memory caching system:

- **How It Works:** When a query is submitted, the cache is checked first. If a response exists in the cache (and hasn't expired), it is returned immediately. Otherwise, a new response is generated, stored in the cache, and then returned to the user.
- **Expiration:** Cached responses expire after a configurable period (default is 5 minutes) to ensure that responses stay up-to-date.
- **Configuration:** The cache expiration time can be adjusted by modifying the `CACHE_EXPIRATION_TIME` variable in the `main.py` file.

### Example Cache Code Snippet:
```python
# In-memory cache for FAQs
cache = {}
CACHE_EXPIRATION_TIME = 300  # Cache expiration time in seconds (5 minutes)

# Cache checking function
def get_cached_response(query: str):
    current_time = time.time()
    if query in cache:
        response_data = cache[query]
        if current_time - response_data['timestamp'] < CACHE_EXPIRATION_TIME:
            return response_data['response']
        else:
            del cache[query]  # Remove expired cache entry
    return None

# Function to cache responses
def cache_response(query: str, response: str):
    cache[query] = {
        "response": response,
        "timestamp": time.time()
    }
```

## Testing Procedures

### Running the Test Suite
The project includes a comprehensive test suite to ensure the functionality of each component. Tests are written using Python's unittest framework and cover:
- PDF Processing: Text extraction and cleaning.
- PDF State Management: Storage and retrieval of PDFs.
- API Endpoints: Uploading PDFs and interacting with them.
- Gemini API Integration: Interaction with the Gemini API.
- Integration Tests: End-to-end testing of the application.

1. **Install Test Dependencies**
   Make sure you have the test dependencies installed:
   ```bash
   pip install -r requirements-test.txt
   ```

2. **Run Tests**
   You can run all tests using:
   ```bash
   python -m unittest discover tests
   ```
   Alternatively, you can run individual test files:
   ```bash
   python -m unittest tests/test_pdf_processing.py
   python -m unittest tests/test_state_management.py
   python -m unittest tests/test_pdf_upload.py
   python -m unittest tests/test_gemini_integration.py
   python -m unittest tests/test_integration.py
   ```

3. **Test Coverage**
   To check test coverage, you can use coverage.py:
   ```bash
   pip install coverage
   coverage run -m unittest discover tests
   coverage report -m
   ```

### Testing Notes
- Ensure the server is not running when you execute the tests.
- Some tests may require internet access to communicate with the Gemini API.
- Mocking is used in some tests to simulate API responses.

## Logging
The application uses a custom logging configuration defined in `logging_config.py`. Logs are outputted in JSON format to `app.log`, with rotating file handlers to manage log file sizes.

### Log Configuration
- **Log Format:** JSON
- **Log Levels:** DEBUG and above
- **Log File:** app.log
- **Rotation:** Maximum file size of 1MB, with up to 3 backups.

Example Log Entry:
```json
{
  "level": "INFO",
  "time": "2023-10-01T12:34:56",
  "message": "Received request to upload PDF.",
  "path": "/path/to/main.py",
  "line": 50
}
```

## Additional Information

### Handling Environment Variables
Ensure that sensitive information, like API keys, is not hard-coded in the source code. Use environment variables and the `.env` file (which should not be committed to version control) to manage such information.

### Dependency Management
Keep your dependencies updated and manage them using `requirements.txt`. For development and testing, you might have separate `requirements-dev.txt` or `requirements-test.txt`.

### Error Handling
The application uses FastAPI's exception handling mechanisms to provide meaningful error responses to the client. Custom exceptions are raised with appropriate HTTP status codes and error messages.

## Conclusion
This project provides a robust and scalable API for interacting with PDF documents using natural language queries. With proper setup and testing, it can be extended or integrated into larger systems requiring document processing and AI-based query handling.
